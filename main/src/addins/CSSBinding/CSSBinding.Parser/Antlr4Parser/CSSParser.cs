// Author:
//       Diyoda Sajjana <>
//
// Copyright (c) 2013 Diyoda Sajjana
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated from CSS.g4 by ANTLR 4.0.1-SNAPSHOT
namespace MonoDevelop.CSSParser {

	using Antlr4.Runtime;
	using Antlr4.Runtime.Atn;
	using Antlr4.Runtime.Misc;
	using Antlr4.Runtime.Tree;
	using System.Collections.Generic;
	using DFA = Antlr4.Runtime.Dfa.DFA;
	public partial class CSSParser : Parser
	{
		public const int
			COMMENT = 1, CDO = 2, CDC = 3, INCLUDES = 4, DASHMATCH = 5, GREATER = 6, LBRACE = 7,
			RBRACE = 8, LBRACKET = 9, RBRACKET = 10, OPEQ = 11, SEMI = 12, COLON = 13, SOLIDUS = 14,
			MINUS = 15, PLUS = 16, STAR = 17, LPAREN = 18, RPAREN = 19, COMMA = 20, DOT = 21, STRING = 22,
			IDENT = 23, HASH = 24, IMPORT_SYM = 25, PAGE_SYM = 26, MEDIA_SYM = 27, CHARSET_SYM = 28,
			IMPORTANT_SYM = 29, EMS = 30, EXS = 31, LENGTH = 32, TIME = 33, ANGLE = 34, FREQ = 35,
			DIMENSION = 36, PERCENTAGE = 37, NUMBER = 38, URI = 39, WS = 40, NL = 41;
		public static readonly string[] tokenNames = {
			"<INVALID>", "COMMENT", "'<!--'", "'-->'", "'~='", "'|='", "'>'", "'{'", 
			"'}'", "'['", "']'", "'='", "';'", "':'", "'/'", "'-'", "'+'", "'*'", 
			"'('", "')'", "','", "'.'", "STRING", "IDENT", "HASH", "IMPORT_SYM", "PAGE_SYM", 
			"MEDIA_SYM", "'@charset '", "IMPORTANT_SYM", "EMS", "EXS", "LENGTH", "TIME", 
			"ANGLE", "FREQ", "DIMENSION", "PERCENTAGE", "NUMBER", "URI", "WS", "NL"
		};
		public const int
			RULE_styleSheet = 0, RULE_charSet = 1, RULE_imports = 2, RULE_media = 3,
			RULE_medium = 4, RULE_bodylist = 5, RULE_bodyset = 6, RULE_page = 7, RULE_pseudoPage = 8,
			RULE_operatorx = 9, RULE_combinator = 10, RULE_unaryOperator = 11, RULE_property = 12,
			RULE_ruleSet = 13, RULE_selector = 14, RULE_simpleSelector = 15, RULE_elementSubsequent = 16,
			RULE_cssClass = 17, RULE_elementName = 18, RULE_attrib = 19, RULE_pseudo = 20,
			RULE_declaration = 21, RULE_prio = 22, RULE_expr = 23, RULE_term = 24,
			RULE_hexColor = 25, RULE_comment = 26;
		public static readonly string[] ruleNames = {
			"styleSheet", "charSet", "imports", "media", "medium", "bodylist", "bodyset", 
			"page", "pseudoPage", "operatorx", "combinator", "unaryOperator", "property", 
			"ruleSet", "selector", "simpleSelector", "elementSubsequent", "cssClass", 
			"elementName", "attrib", "pseudo", "declaration", "prio", "expr", "term", 
			"hexColor", "comment"
		};

		public override string GrammarFileName { get { return "CSS.g4"; } }

		public override string[] TokenNames { get { return tokenNames; } }

		public override string[] RuleNames { get { return ruleNames; } }


		protected const int EOF = Eof;

		public CSSParser(ITokenStream input)
			: base(input)
		{
			_interp = new ParserATNSimulator(this, _ATN);
		}
		public partial class StyleSheetContext : ParserRuleContext
		{
			public ImportsContext imports(int i)
			{
				return GetRuleContext<ImportsContext>(i);
			}
			public BodylistContext bodylist()
			{
				return GetRuleContext<BodylistContext>(0);
			}
			public CharSetContext charSet()
			{
				return GetRuleContext<CharSetContext>(0);
			}
			public ITerminalNode EOF() { return GetToken(CSSParser.EOF, 0); }
			public IList<ImportsContext> imports()
			{
				return GetRuleContexts<ImportsContext>();
			}
			public StyleSheetContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_styleSheet; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterStyleSheet(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitStyleSheet(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitStyleSheet(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public StyleSheetContext styleSheet()
		{
			StyleSheetContext _localctx = new StyleSheetContext(_ctx, State);
			EnterRule(_localctx, 0, RULE_styleSheet);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 54; charSet();
					State = 58;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la == IMPORT_SYM)
					{
						{
							{
								State = 55; imports();
							}
						}
						State = 60;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 61; bodylist();
					State = 62; Match(EOF);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class CharSetContext : ParserRuleContext
		{
			public ITerminalNode CHARSET_SYM() { return GetToken(CSSParser.CHARSET_SYM, 0); }
			public ITerminalNode SEMI() { return GetToken(CSSParser.SEMI, 0); }
			public ITerminalNode STRING() { return GetToken(CSSParser.STRING, 0); }
			public CharSetContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_charSet; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterCharSet(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitCharSet(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitCharSet(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public CharSetContext charSet()
		{
			CharSetContext _localctx = new CharSetContext(_ctx, State);
			EnterRule(_localctx, 2, RULE_charSet);
			try
			{
				State = 68;
				switch (_input.La(1))
				{
					case CHARSET_SYM:
					EnterOuterAlt(_localctx, 1);
					{
						State = 64; Match(CHARSET_SYM);
						State = 65; Match(STRING);
						State = 66; Match(SEMI);
					}
					break;
					case EOF:
					case LBRACKET:
					case COLON:
					case STAR:
					case DOT:
					case IDENT:
					case HASH:
					case IMPORT_SYM:
					case PAGE_SYM:
					case MEDIA_SYM:
					EnterOuterAlt(_localctx, 2);
					{
					}
					break;
					default:
					throw new NoViableAltException(this);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ImportsContext : ParserRuleContext
		{
			public MediumContext medium(int i)
			{
				return GetRuleContext<MediumContext>(i);
			}
			public ITerminalNode COMMA(int i)
			{
				return GetToken(CSSParser.COMMA, i);
			}
			public IList<ITerminalNode> COMMA() { return GetTokens(CSSParser.COMMA); }
			public ITerminalNode IMPORT_SYM() { return GetToken(CSSParser.IMPORT_SYM, 0); }
			public ITerminalNode SEMI() { return GetToken(CSSParser.SEMI, 0); }
			public IList<MediumContext> medium()
			{
				return GetRuleContexts<MediumContext>();
			}
			public ITerminalNode STRING() { return GetToken(CSSParser.STRING, 0); }
			public ITerminalNode URI() { return GetToken(CSSParser.URI, 0); }
			public ImportsContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_imports; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterImports(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitImports(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitImports(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public ImportsContext imports()
		{
			ImportsContext _localctx = new ImportsContext(_ctx, State);
			EnterRule(_localctx, 4, RULE_imports);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 70; Match(IMPORT_SYM);
					State = 71;
					_la = _input.La(1);
					if (!(_la == STRING || _la == URI))
					{
						_errHandler.RecoverInline(this);
					}
					Consume();
					State = 80;
					_la = _input.La(1);
					if (_la == IDENT)
					{
						{
							State = 72; medium();
							State = 77;
							_errHandler.Sync(this);
							_la = _input.La(1);
							while (_la == COMMA)
							{
								{
									{
										State = 73; Match(COMMA);
										State = 74; medium();
									}
								}
								State = 79;
								_errHandler.Sync(this);
								_la = _input.La(1);
							}
						}
					}

					State = 82; Match(SEMI);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class MediaContext : ParserRuleContext
		{
			public MediumContext medium(int i)
			{
				return GetRuleContext<MediumContext>(i);
			}
			public ITerminalNode COMMA(int i)
			{
				return GetToken(CSSParser.COMMA, i);
			}
			public ITerminalNode RBRACE() { return GetToken(CSSParser.RBRACE, 0); }
			public IList<ITerminalNode> COMMA() { return GetTokens(CSSParser.COMMA); }
			public ITerminalNode MEDIA_SYM() { return GetToken(CSSParser.MEDIA_SYM, 0); }
			public RuleSetContext ruleSet()
			{
				return GetRuleContext<RuleSetContext>(0);
			}
			public ITerminalNode LBRACE() { return GetToken(CSSParser.LBRACE, 0); }
			public IList<MediumContext> medium()
			{
				return GetRuleContexts<MediumContext>();
			}
			public MediaContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_media; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterMedia(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitMedia(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitMedia(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public MediaContext media()
		{
			MediaContext _localctx = new MediaContext(_ctx, State);
			EnterRule(_localctx, 6, RULE_media);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 84; Match(MEDIA_SYM);
					State = 85; medium();
					State = 90;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la == COMMA)
					{
						{
							{
								State = 86; Match(COMMA);
								State = 87; medium();
							}
						}
						State = 92;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 93; Match(LBRACE);
					State = 94; ruleSet();
					State = 95; Match(RBRACE);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class MediumContext : ParserRuleContext
		{
			public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
			public MediumContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_medium; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterMedium(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitMedium(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitMedium(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public MediumContext medium()
		{
			MediumContext _localctx = new MediumContext(_ctx, State);
			EnterRule(_localctx, 8, RULE_medium);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 97; Match(IDENT);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class BodylistContext : ParserRuleContext
		{
			public BodysetContext bodyset(int i)
			{
				return GetRuleContext<BodysetContext>(i);
			}
			public IList<BodysetContext> bodyset()
			{
				return GetRuleContexts<BodysetContext>();
			}
			public BodylistContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_bodylist; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterBodylist(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitBodylist(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitBodylist(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public BodylistContext bodylist()
		{
			BodylistContext _localctx = new BodylistContext(_ctx, State);
			EnterRule(_localctx, 10, RULE_bodylist);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 102;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LBRACKET) | (1L << COLON) | (1L << STAR) | (1L << DOT) | (1L << IDENT) | (1L << HASH) | (1L << PAGE_SYM) | (1L << MEDIA_SYM))) != 0))
					{
						{
							{
								State = 99; bodyset();
							}
						}
						State = 104;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class BodysetContext : ParserRuleContext
		{
			public PageContext page()
			{
				return GetRuleContext<PageContext>(0);
			}
			public MediaContext media()
			{
				return GetRuleContext<MediaContext>(0);
			}
			public RuleSetContext ruleSet()
			{
				return GetRuleContext<RuleSetContext>(0);
			}
			public BodysetContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_bodyset; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterBodyset(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitBodyset(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitBodyset(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public BodysetContext bodyset()
		{
			BodysetContext _localctx = new BodysetContext(_ctx, State);
			EnterRule(_localctx, 12, RULE_bodyset);
			try
			{
				State = 108;
				switch (_input.La(1))
				{
					case LBRACKET:
					case COLON:
					case STAR:
					case DOT:
					case IDENT:
					case HASH:
					EnterOuterAlt(_localctx, 1);
					{
						State = 105; ruleSet();
					}
					break;
					case MEDIA_SYM:
					EnterOuterAlt(_localctx, 2);
					{
						State = 106; media();
					}
					break;
					case PAGE_SYM:
					EnterOuterAlt(_localctx, 3);
					{
						State = 107; page();
					}
					break;
					default:
					throw new NoViableAltException(this);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PageContext : ParserRuleContext
		{
			public ITerminalNode PAGE_SYM() { return GetToken(CSSParser.PAGE_SYM, 0); }
			public IList<DeclarationContext> declaration()
			{
				return GetRuleContexts<DeclarationContext>();
			}
			public ITerminalNode RBRACE() { return GetToken(CSSParser.RBRACE, 0); }
			public PseudoPageContext pseudoPage()
			{
				return GetRuleContext<PseudoPageContext>(0);
			}
			public DeclarationContext declaration(int i)
			{
				return GetRuleContext<DeclarationContext>(i);
			}
			public IList<ITerminalNode> SEMI() { return GetTokens(CSSParser.SEMI); }
			public ITerminalNode SEMI(int i)
			{
				return GetToken(CSSParser.SEMI, i);
			}
			public ITerminalNode LBRACE() { return GetToken(CSSParser.LBRACE, 0); }
			public PageContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_page; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterPage(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitPage(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitPage(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public PageContext page()
		{
			PageContext _localctx = new PageContext(_ctx, State);
			EnterRule(_localctx, 14, RULE_page);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 110; Match(PAGE_SYM);
					State = 112;
					_la = _input.La(1);
					if (_la == COLON)
					{
						{
							State = 111; pseudoPage();
						}
					}

					State = 114; Match(LBRACE);
					State = 115; declaration();
					State = 116; Match(SEMI);
					State = 122;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la == IDENT)
					{
						{
							{
								State = 117; declaration();
								State = 118; Match(SEMI);
							}
						}
						State = 124;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 125; Match(RBRACE);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PseudoPageContext : ParserRuleContext
		{
			public ITerminalNode COLON() { return GetToken(CSSParser.COLON, 0); }
			public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
			public PseudoPageContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_pseudoPage; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterPseudoPage(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitPseudoPage(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitPseudoPage(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public PseudoPageContext pseudoPage()
		{
			PseudoPageContext _localctx = new PseudoPageContext(_ctx, State);
			EnterRule(_localctx, 16, RULE_pseudoPage);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 127; Match(COLON);
					State = 128; Match(IDENT);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class OperatorxContext : ParserRuleContext
		{
			public ITerminalNode COMMA() { return GetToken(CSSParser.COMMA, 0); }
			public ITerminalNode SOLIDUS() { return GetToken(CSSParser.SOLIDUS, 0); }
			public OperatorxContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_operatorx; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterOperatorx(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitOperatorx(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitOperatorx(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public OperatorxContext operatorx()
		{
			OperatorxContext _localctx = new OperatorxContext(_ctx, State);
			EnterRule(_localctx, 18, RULE_operatorx);
			try
			{
				State = 133;
				switch (_input.La(1))
				{
					case SOLIDUS:
					EnterOuterAlt(_localctx, 1);
					{
						State = 130; Match(SOLIDUS);
					}
					break;
					case COMMA:
					EnterOuterAlt(_localctx, 2);
					{
						State = 131; Match(COMMA);
					}
					break;
					case MINUS:
					case PLUS:
					case STRING:
					case IDENT:
					case HASH:
					case EMS:
					case EXS:
					case LENGTH:
					case TIME:
					case ANGLE:
					case FREQ:
					case PERCENTAGE:
					case NUMBER:
					case URI:
					EnterOuterAlt(_localctx, 3);
					{
					}
					break;
					default:
					throw new NoViableAltException(this);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class CombinatorContext : ParserRuleContext
		{
			public ITerminalNode PLUS() { return GetToken(CSSParser.PLUS, 0); }
			public ITerminalNode GREATER() { return GetToken(CSSParser.GREATER, 0); }
			public CombinatorContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_combinator; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterCombinator(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitCombinator(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitCombinator(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public CombinatorContext combinator()
		{
			CombinatorContext _localctx = new CombinatorContext(_ctx, State);
			EnterRule(_localctx, 20, RULE_combinator);
			try
			{
				State = 138;
				switch (_input.La(1))
				{
					case PLUS:
					EnterOuterAlt(_localctx, 1);
					{
						State = 135; Match(PLUS);
					}
					break;
					case GREATER:
					EnterOuterAlt(_localctx, 2);
					{
						State = 136; Match(GREATER);
					}
					break;
					case LBRACKET:
					case COLON:
					case STAR:
					case DOT:
					case IDENT:
					case HASH:
					EnterOuterAlt(_localctx, 3);
					{
					}
					break;
					default:
					throw new NoViableAltException(this);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class UnaryOperatorContext : ParserRuleContext
		{
			public ITerminalNode PLUS() { return GetToken(CSSParser.PLUS, 0); }
			public ITerminalNode MINUS() { return GetToken(CSSParser.MINUS, 0); }
			public UnaryOperatorContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_unaryOperator; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterUnaryOperator(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitUnaryOperator(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitUnaryOperator(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public UnaryOperatorContext unaryOperator()
		{
			UnaryOperatorContext _localctx = new UnaryOperatorContext(_ctx, State);
			EnterRule(_localctx, 22, RULE_unaryOperator);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 140;
					_la = _input.La(1);
					if (!(_la == MINUS || _la == PLUS))
					{
						_errHandler.RecoverInline(this);
					}
					Consume();
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PropertyContext : ParserRuleContext
		{
			public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
			public PropertyContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_property; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterProperty(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitProperty(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitProperty(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public PropertyContext property()
		{
			PropertyContext _localctx = new PropertyContext(_ctx, State);
			EnterRule(_localctx, 24, RULE_property);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 142; Match(IDENT);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class RuleSetContext : ParserRuleContext
		{
			public IList<SelectorContext> selector()
			{
				return GetRuleContexts<SelectorContext>();
			}
			public IList<DeclarationContext> declaration()
			{
				return GetRuleContexts<DeclarationContext>();
			}
			public ITerminalNode COMMA(int i)
			{
				return GetToken(CSSParser.COMMA, i);
			}
			public SelectorContext selector(int i)
			{
				return GetRuleContext<SelectorContext>(i);
			}
			public ITerminalNode RBRACE() { return GetToken(CSSParser.RBRACE, 0); }
			public IList<ITerminalNode> COMMA() { return GetTokens(CSSParser.COMMA); }
			public DeclarationContext declaration(int i)
			{
				return GetRuleContext<DeclarationContext>(i);
			}
			public IList<ITerminalNode> SEMI() { return GetTokens(CSSParser.SEMI); }
			public ITerminalNode SEMI(int i)
			{
				return GetToken(CSSParser.SEMI, i);
			}
			public ITerminalNode LBRACE() { return GetToken(CSSParser.LBRACE, 0); }
			public RuleSetContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_ruleSet; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterRuleSet(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitRuleSet(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitRuleSet(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public RuleSetContext ruleSet()
		{
			RuleSetContext _localctx = new RuleSetContext(_ctx, State);
			EnterRule(_localctx, 26, RULE_ruleSet);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 144; selector();
					State = 149;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la == COMMA)
					{
						{
							{
								State = 145; Match(COMMA);
								State = 146; selector();
							}
						}
						State = 151;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 152; Match(LBRACE);
					State = 153; declaration();
					State = 154; Match(SEMI);
					State = 160;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la == IDENT)
					{
						{
							{
								State = 155; declaration();
								State = 156; Match(SEMI);
							}
						}
						State = 162;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 163; Match(RBRACE);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class SelectorContext : ParserRuleContext
		{
			public SimpleSelectorContext simpleSelector(int i)
			{
				return GetRuleContext<SimpleSelectorContext>(i);
			}
			public CombinatorContext combinator(int i)
			{
				return GetRuleContext<CombinatorContext>(i);
			}
			public IList<CombinatorContext> combinator()
			{
				return GetRuleContexts<CombinatorContext>();
			}
			public IList<SimpleSelectorContext> simpleSelector()
			{
				return GetRuleContexts<SimpleSelectorContext>();
			}
			public SelectorContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_selector; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterSelector(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitSelector(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitSelector(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public SelectorContext selector()
		{
			SelectorContext _localctx = new SelectorContext(_ctx, State);
			EnterRule(_localctx, 28, RULE_selector);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 165; simpleSelector();
					State = 171;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << GREATER) | (1L << LBRACKET) | (1L << COLON) | (1L << PLUS) | (1L << STAR) | (1L << DOT) | (1L << IDENT) | (1L << HASH))) != 0))
					{
						{
							{
								State = 166; combinator();
								State = 167; simpleSelector();
							}
						}
						State = 173;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class SimpleSelectorContext : ParserRuleContext
		{
			public ElementSubsequentContext elementSubsequent(int i)
			{
				return GetRuleContext<ElementSubsequentContext>(i);
			}
			public ElementNameContext elementName()
			{
				return GetRuleContext<ElementNameContext>(0);
			}
			public IList<ElementSubsequentContext> elementSubsequent()
			{
				return GetRuleContexts<ElementSubsequentContext>();
			}
			public SimpleSelectorContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_simpleSelector; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterSimpleSelector(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitSimpleSelector(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitSimpleSelector(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public SimpleSelectorContext simpleSelector()
		{
			SimpleSelectorContext _localctx = new SimpleSelectorContext(_ctx, State);
			EnterRule(_localctx, 30, RULE_simpleSelector);
			try
			{
				int _alt;
				State = 186;
				switch (_input.La(1))
				{
					case STAR:
					case IDENT:
					EnterOuterAlt(_localctx, 1);
					{
						State = 174; elementName();
						State = 178;
						_errHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(_input, 14, _ctx);
						while (_alt != 2 && _alt != -1)
						{
							if (_alt == 1)
							{
								{
									{
										State = 175; elementSubsequent();
									}
								}
							}
							State = 180;
							_errHandler.Sync(this);
							_alt = Interpreter.AdaptivePredict(_input, 14, _ctx);
						}
					}
					break;
					case LBRACKET:
					case COLON:
					case DOT:
					case HASH:
					EnterOuterAlt(_localctx, 2);
					{
						State = 182;
						_errHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(_input, 15, _ctx);
						do
						{
							switch (_alt)
							{
								case 1:
							{
								{
									State = 181; elementSubsequent();
								}
							}
								break;
								default:
								throw new NoViableAltException(this);
							}
							State = 184;
							_errHandler.Sync(this);
							_alt = Interpreter.AdaptivePredict(_input, 15, _ctx);
						} while (_alt != 2 && _alt != -1);
					}
					break;
					default:
					throw new NoViableAltException(this);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ElementSubsequentContext : ParserRuleContext
		{
			public ITerminalNode HASH() { return GetToken(CSSParser.HASH, 0); }
			public PseudoContext pseudo()
			{
				return GetRuleContext<PseudoContext>(0);
			}
			public CssClassContext cssClass()
			{
				return GetRuleContext<CssClassContext>(0);
			}
			public AttribContext attrib()
			{
				return GetRuleContext<AttribContext>(0);
			}
			public ElementSubsequentContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_elementSubsequent; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterElementSubsequent(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitElementSubsequent(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitElementSubsequent(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public ElementSubsequentContext elementSubsequent()
		{
			ElementSubsequentContext _localctx = new ElementSubsequentContext(_ctx, State);
			EnterRule(_localctx, 32, RULE_elementSubsequent);
			try
			{
				State = 192;
				switch (_input.La(1))
				{
					case HASH:
					EnterOuterAlt(_localctx, 1);
					{
						State = 188; Match(HASH);
					}
					break;
					case DOT:
					EnterOuterAlt(_localctx, 2);
					{
						State = 189; cssClass();
					}
					break;
					case LBRACKET:
					EnterOuterAlt(_localctx, 3);
					{
						State = 190; attrib();
					}
					break;
					case COLON:
					EnterOuterAlt(_localctx, 4);
					{
						State = 191; pseudo();
					}
					break;
					default:
					throw new NoViableAltException(this);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class CssClassContext : ParserRuleContext
		{
			public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
			public ITerminalNode DOT() { return GetToken(CSSParser.DOT, 0); }
			public CssClassContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_cssClass; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterCssClass(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitCssClass(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitCssClass(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public CssClassContext cssClass()
		{
			CssClassContext _localctx = new CssClassContext(_ctx, State);
			EnterRule(_localctx, 34, RULE_cssClass);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 194; Match(DOT);
					State = 195; Match(IDENT);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ElementNameContext : ParserRuleContext
		{
			public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
			public ITerminalNode STAR() { return GetToken(CSSParser.STAR, 0); }
			public ElementNameContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_elementName; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterElementName(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitElementName(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitElementName(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public ElementNameContext elementName()
		{
			ElementNameContext _localctx = new ElementNameContext(_ctx, State);
			EnterRule(_localctx, 36, RULE_elementName);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 197;
					_la = _input.La(1);
					if (!(_la == STAR || _la == IDENT))
					{
						_errHandler.RecoverInline(this);
					}
					Consume();
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class AttribContext : ParserRuleContext
		{
			public ITerminalNode INCLUDES() { return GetToken(CSSParser.INCLUDES, 0); }
			public ITerminalNode LBRACKET() { return GetToken(CSSParser.LBRACKET, 0); }
			public IList<ITerminalNode> IDENT() { return GetTokens(CSSParser.IDENT); }
			public ITerminalNode DASHMATCH() { return GetToken(CSSParser.DASHMATCH, 0); }
			public ITerminalNode OPEQ() { return GetToken(CSSParser.OPEQ, 0); }
			public ITerminalNode RBRACKET() { return GetToken(CSSParser.RBRACKET, 0); }
			public ITerminalNode IDENT(int i)
			{
				return GetToken(CSSParser.IDENT, i);
			}
			public ITerminalNode STRING() { return GetToken(CSSParser.STRING, 0); }
			public AttribContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_attrib; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterAttrib(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitAttrib(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitAttrib(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public AttribContext attrib()
		{
			AttribContext _localctx = new AttribContext(_ctx, State);
			EnterRule(_localctx, 38, RULE_attrib);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 199; Match(LBRACKET);
					State = 200; Match(IDENT);
					State = 203;
					_la = _input.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INCLUDES) | (1L << DASHMATCH) | (1L << OPEQ))) != 0))
					{
						{
							State = 201;
							_la = _input.La(1);
							if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INCLUDES) | (1L << DASHMATCH) | (1L << OPEQ))) != 0)))
							{
								_errHandler.RecoverInline(this);
							}
							Consume();
							State = 202;
							_la = _input.La(1);
							if (!(_la == STRING || _la == IDENT))
							{
								_errHandler.RecoverInline(this);
							}
							Consume();
						}
					}

					State = 205; Match(RBRACKET);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PseudoContext : ParserRuleContext
		{
			public ITerminalNode COLON() { return GetToken(CSSParser.COLON, 0); }
			public ITerminalNode RPAREN() { return GetToken(CSSParser.RPAREN, 0); }
			public IList<ITerminalNode> IDENT() { return GetTokens(CSSParser.IDENT); }
			public ITerminalNode IDENT(int i)
			{
				return GetToken(CSSParser.IDENT, i);
			}
			public ITerminalNode LPAREN() { return GetToken(CSSParser.LPAREN, 0); }
			public PseudoContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_pseudo; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterPseudo(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitPseudo(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitPseudo(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public PseudoContext pseudo()
		{
			PseudoContext _localctx = new PseudoContext(_ctx, State);
			EnterRule(_localctx, 40, RULE_pseudo);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 207; Match(COLON);
					State = 208; Match(IDENT);
					State = 214;
					_la = _input.La(1);
					if (_la == LPAREN)
					{
						{
							State = 209; Match(LPAREN);
							State = 211;
							_la = _input.La(1);
							if (_la == IDENT)
							{
								{
									State = 210; Match(IDENT);
								}
							}

							State = 213; Match(RPAREN);
						}
					}

				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class DeclarationContext : ParserRuleContext
		{
			public ITerminalNode COLON() { return GetToken(CSSParser.COLON, 0); }
			public ExprContext expr()
			{
				return GetRuleContext<ExprContext>(0);
			}
			public PropertyContext property()
			{
				return GetRuleContext<PropertyContext>(0);
			}
			public PrioContext prio()
			{
				return GetRuleContext<PrioContext>(0);
			}
			public DeclarationContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_declaration; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterDeclaration(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitDeclaration(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public DeclarationContext declaration()
		{
			DeclarationContext _localctx = new DeclarationContext(_ctx, State);
			EnterRule(_localctx, 42, RULE_declaration);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 216; property();
					State = 217; Match(COLON);
					State = 218; expr();
					State = 220;
					_la = _input.La(1);
					if (_la == IMPORTANT_SYM)
					{
						{
							State = 219; prio();
						}
					}

				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PrioContext : ParserRuleContext
		{
			public ITerminalNode IMPORTANT_SYM() { return GetToken(CSSParser.IMPORTANT_SYM, 0); }
			public PrioContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_prio; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterPrio(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitPrio(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitPrio(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public PrioContext prio()
		{
			PrioContext _localctx = new PrioContext(_ctx, State);
			EnterRule(_localctx, 44, RULE_prio);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 222; Match(IMPORTANT_SYM);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ExprContext : ParserRuleContext
		{
			public IList<OperatorxContext> operatorx()
			{
				return GetRuleContexts<OperatorxContext>();
			}
			public IList<TermContext> term()
			{
				return GetRuleContexts<TermContext>();
			}
			public OperatorxContext operatorx(int i)
			{
				return GetRuleContext<OperatorxContext>(i);
			}
			public TermContext term(int i)
			{
				return GetRuleContext<TermContext>(i);
			}
			public ExprContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_expr; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterExpr(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitExpr(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitExpr(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public ExprContext expr()
		{
			ExprContext _localctx = new ExprContext(_ctx, State);
			EnterRule(_localctx, 46, RULE_expr);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 224; term();
					State = 230;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << SOLIDUS) | (1L << MINUS) | (1L << PLUS) | (1L << COMMA) | (1L << STRING) | (1L << IDENT) | (1L << HASH) | (1L << EMS) | (1L << EXS) | (1L << LENGTH) | (1L << TIME) | (1L << ANGLE) | (1L << FREQ) | (1L << PERCENTAGE) | (1L << NUMBER) | (1L << URI))) != 0))
					{
						{
							{
								State = 225; operatorx();
								State = 226; term();
							}
						}
						State = 232;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class TermContext : ParserRuleContext
		{
			public ITerminalNode TIME() { return GetToken(CSSParser.TIME, 0); }
			public ITerminalNode RPAREN() { return GetToken(CSSParser.RPAREN, 0); }
			public ITerminalNode ANGLE() { return GetToken(CSSParser.ANGLE, 0); }
			public ITerminalNode EMS() { return GetToken(CSSParser.EMS, 0); }
			public ExprContext expr()
			{
				return GetRuleContext<ExprContext>(0);
			}
			public ITerminalNode EXS() { return GetToken(CSSParser.EXS, 0); }
			public ITerminalNode NUMBER() { return GetToken(CSSParser.NUMBER, 0); }
			public UnaryOperatorContext unaryOperator()
			{
				return GetRuleContext<UnaryOperatorContext>(0);
			}
			public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
			public HexColorContext hexColor()
			{
				return GetRuleContext<HexColorContext>(0);
			}
			public ITerminalNode FREQ() { return GetToken(CSSParser.FREQ, 0); }
			public ITerminalNode PERCENTAGE() { return GetToken(CSSParser.PERCENTAGE, 0); }
			public ITerminalNode LENGTH() { return GetToken(CSSParser.LENGTH, 0); }
			public ITerminalNode LPAREN() { return GetToken(CSSParser.LPAREN, 0); }
			public ITerminalNode STRING() { return GetToken(CSSParser.STRING, 0); }
			public ITerminalNode URI() { return GetToken(CSSParser.URI, 0); }
			public TermContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_term; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterTerm(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitTerm(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitTerm(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public TermContext term()
		{
			TermContext _localctx = new TermContext(_ctx, State);
			EnterRule(_localctx, 48, RULE_term);
			int _la;
			try
			{
				State = 247;
				switch (_input.La(1))
				{
					case MINUS:
					case PLUS:
					case EMS:
					case EXS:
					case LENGTH:
					case TIME:
					case ANGLE:
					case FREQ:
					case PERCENTAGE:
					case NUMBER:
					EnterOuterAlt(_localctx, 1);
					{
						State = 234;
						_la = _input.La(1);
						if (_la == MINUS || _la == PLUS)
						{
							{
								State = 233; unaryOperator();
							}
						}

						State = 236;
						_la = _input.La(1);
						if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EMS) | (1L << EXS) | (1L << LENGTH) | (1L << TIME) | (1L << ANGLE) | (1L << FREQ) | (1L << PERCENTAGE) | (1L << NUMBER))) != 0)))
						{
							_errHandler.RecoverInline(this);
						}
						Consume();
					}
					break;
					case STRING:
					EnterOuterAlt(_localctx, 2);
					{
						State = 237; Match(STRING);
					}
					break;
					case IDENT:
					EnterOuterAlt(_localctx, 3);
					{
						State = 238; Match(IDENT);
						State = 243;
						_la = _input.La(1);
						if (_la == LPAREN)
						{
							{
								State = 239; Match(LPAREN);
								State = 240; expr();
								State = 241; Match(RPAREN);
							}
						}

					}
					break;
					case URI:
					EnterOuterAlt(_localctx, 4);
					{
						State = 245; Match(URI);
					}
					break;
					case HASH:
					EnterOuterAlt(_localctx, 5);
					{
						State = 246; hexColor();
					}
					break;
					default:
					throw new NoViableAltException(this);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class HexColorContext : ParserRuleContext
		{
			public ITerminalNode HASH() { return GetToken(CSSParser.HASH, 0); }
			public HexColorContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_hexColor; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterHexColor(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitHexColor(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitHexColor(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public HexColorContext hexColor()
		{
			HexColorContext _localctx = new HexColorContext(_ctx, State);
			EnterRule(_localctx, 50, RULE_hexColor);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 249; Match(HASH);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class CommentContext : ParserRuleContext
		{
			public ITerminalNode COMMENT() { return GetToken(CSSParser.COMMENT, 0); }
			public CommentContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int GetRuleIndex() { return RULE_comment; }
			public override void EnterRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.EnterComment(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				ICSSListener typedListener = listener as ICSSListener;
				if (typedListener != null) typedListener.ExitComment(this);
			}
			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ICSSVisitor<TResult> typedVisitor = visitor as ICSSVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitComment(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public CommentContext comment()
		{
			CommentContext _localctx = new CommentContext(_ctx, State);
			EnterRule(_localctx, 52, RULE_comment);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 251; Match(COMMENT);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				_errHandler.ReportError(this, re);
				_errHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public static readonly string _serializedATN =
			"\x5\x3+\x100\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4" +
				"\a\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE" +
				"\x4\xF\t\xF\x4\x10\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14" +
				"\t\x14\x4\x15\t\x15\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19" +
				"\x4\x1A\t\x1A\x4\x1B\t\x1B\x4\x1C\t\x1C\x3\x2\x3\x2\a\x2;\n\x2\f\x2\xE" +
				"\x2>\v\x2\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x3\x3\x5\x3G\n\x3\x3\x4" +
				"\x3\x4\x3\x4\x3\x4\x3\x4\a\x4N\n\x4\f\x4\xE\x4Q\v\x4\x5\x4S\n\x4\x3\x4" +
				"\x3\x4\x3\x5\x3\x5\x3\x5\x3\x5\a\x5[\n\x5\f\x5\xE\x5^\v\x5\x3\x5\x3\x5" +
				"\x3\x5\x3\x5\x3\x6\x3\x6\x3\a\a\ag\n\a\f\a\xE\aj\v\a\x3\b\x3\b\x3\b\x5" +
				"\bo\n\b\x3\t\x3\t\x5\ts\n\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\a\t{\n\t\f\t" +
				"\xE\t~\v\t\x3\t\x3\t\x3\n\x3\n\x3\n\x3\v\x3\v\x3\v\x5\v\x88\n\v\x3\f\x3" +
				"\f\x3\f\x5\f\x8D\n\f\x3\r\x3\r\x3\xE\x3\xE\x3\xF\x3\xF\x3\xF\a\xF\x96" +
				"\n\xF\f\xF\xE\xF\x99\v\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\a\xF\xA1" +
				"\n\xF\f\xF\xE\xF\xA4\v\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10\x3\x10\a\x10" +
				"\xAC\n\x10\f\x10\xE\x10\xAF\v\x10\x3\x11\x3\x11\a\x11\xB3\n\x11\f\x11" +
				"\xE\x11\xB6\v\x11\x3\x11\x6\x11\xB9\n\x11\r\x11\xE\x11\xBA\x5\x11\xBD" +
				"\n\x11\x3\x12\x3\x12\x3\x12\x3\x12\x5\x12\xC3\n\x12\x3\x13\x3\x13\x3\x13" +
				"\x3\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3\x15\x5\x15\xCE\n\x15\x3\x15\x3" +
				"\x15\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\xD6\n\x16\x3\x16\x5\x16\xD9\n" +
				"\x16\x3\x17\x3\x17\x3\x17\x3\x17\x5\x17\xDF\n\x17\x3\x18\x3\x18\x3\x19" +
				"\x3\x19\x3\x19\x3\x19\a\x19\xE7\n\x19\f\x19\xE\x19\xEA\v\x19\x3\x1A\x5" +
				"\x1A\xED\n\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x5\x1A" +
				"\xF6\n\x1A\x3\x1A\x3\x1A\x5\x1A\xFA\n\x1A\x3\x1B\x3\x1B\x3\x1C\x3\x1C" +
				"\x3\x1C\x2\x2\x2\x1D\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12" +
				"\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2(\x2*\x2" +
				",\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x2\b\x4\x18\x18))\x3\x11\x12\x4\x13" +
				"\x13\x19\x19\x4\x6\a\r\r\x3\x18\x19\x4 %\'(\x106\x2\x38\x3\x2\x2\x2\x4" +
				"\x46\x3\x2\x2\x2\x6H\x3\x2\x2\x2\bV\x3\x2\x2\x2\n\x63\x3\x2\x2\x2\fh\x3" +
				"\x2\x2\x2\xEn\x3\x2\x2\x2\x10p\x3\x2\x2\x2\x12\x81\x3\x2\x2\x2\x14\x87" +
				"\x3\x2\x2\x2\x16\x8C\x3\x2\x2\x2\x18\x8E\x3\x2\x2\x2\x1A\x90\x3\x2\x2" +
				"\x2\x1C\x92\x3\x2\x2\x2\x1E\xA7\x3\x2\x2\x2 \xBC\x3\x2\x2\x2\"\xC2\x3" +
				"\x2\x2\x2$\xC4\x3\x2\x2\x2&\xC7\x3\x2\x2\x2(\xC9\x3\x2\x2\x2*\xD1\x3\x2" +
				"\x2\x2,\xDA\x3\x2\x2\x2.\xE0\x3\x2\x2\x2\x30\xE2\x3\x2\x2\x2\x32\xF9\x3" +
				"\x2\x2\x2\x34\xFB\x3\x2\x2\x2\x36\xFD\x3\x2\x2\x2\x38<\x5\x4\x3\x2\x39" +
				";\x5\x6\x4\x2:\x39\x3\x2\x2\x2;>\x3\x2\x2\x2<:\x3\x2\x2\x2<=\x3\x2\x2" +
				"\x2=?\x3\x2\x2\x2><\x3\x2\x2\x2?@\x5\f\a\x2@\x41\a\x1\x2\x2\x41\x3\x3" +
				"\x2\x2\x2\x42\x43\a\x1E\x2\x2\x43\x44\a\x18\x2\x2\x44G\a\xE\x2\x2\x45" +
				"G\x3\x2\x2\x2\x46\x42\x3\x2\x2\x2\x46\x45\x3\x2\x2\x2G\x5\x3\x2\x2\x2" +
				"HI\a\x1B\x2\x2IR\t\x2\x2\x2JO\x5\n\x6\x2KL\a\x16\x2\x2LN\x5\n\x6\x2MK" +
				"\x3\x2\x2\x2NQ\x3\x2\x2\x2OM\x3\x2\x2\x2OP\x3\x2\x2\x2PS\x3\x2\x2\x2Q" +
				"O\x3\x2\x2\x2RJ\x3\x2\x2\x2RS\x3\x2\x2\x2ST\x3\x2\x2\x2TU\a\xE\x2\x2U" +
				"\a\x3\x2\x2\x2VW\a\x1D\x2\x2W\\\x5\n\x6\x2XY\a\x16\x2\x2Y[\x5\n\x6\x2" +
				"ZX\x3\x2\x2\x2[^\x3\x2\x2\x2\\Z\x3\x2\x2\x2\\]\x3\x2\x2\x2]_\x3\x2\x2" +
				"\x2^\\\x3\x2\x2\x2_`\a\t\x2\x2`\x61\x5\x1C\xF\x2\x61\x62\a\n\x2\x2\x62" +
				"\t\x3\x2\x2\x2\x63\x64\a\x19\x2\x2\x64\v\x3\x2\x2\x2\x65g\x5\xE\b\x2\x66" +
				"\x65\x3\x2\x2\x2gj\x3\x2\x2\x2h\x66\x3\x2\x2\x2hi\x3\x2\x2\x2i\r\x3\x2" +
				"\x2\x2jh\x3\x2\x2\x2ko\x5\x1C\xF\x2lo\x5\b\x5\x2mo\x5\x10\t\x2nk\x3\x2" +
				"\x2\x2nl\x3\x2\x2\x2nm\x3\x2\x2\x2o\xF\x3\x2\x2\x2pr\a\x1C\x2\x2qs\x5" +
				"\x12\n\x2rq\x3\x2\x2\x2rs\x3\x2\x2\x2st\x3\x2\x2\x2tu\a\t\x2\x2uv\x5," +
				"\x17\x2v|\a\xE\x2\x2wx\x5,\x17\x2xy\a\xE\x2\x2y{\x3\x2\x2\x2zw\x3\x2\x2" +
				"\x2{~\x3\x2\x2\x2|z\x3\x2\x2\x2|}\x3\x2\x2\x2}\x7F\x3\x2\x2\x2~|\x3\x2" +
				"\x2\x2\x7F\x80\a\n\x2\x2\x80\x11\x3\x2\x2\x2\x81\x82\a\xF\x2\x2\x82\x83" +
				"\a\x19\x2\x2\x83\x13\x3\x2\x2\x2\x84\x88\a\x10\x2\x2\x85\x88\a\x16\x2" +
				"\x2\x86\x88\x3\x2\x2\x2\x87\x84\x3\x2\x2\x2\x87\x85\x3\x2\x2\x2\x87\x86" +
				"\x3\x2\x2\x2\x88\x15\x3\x2\x2\x2\x89\x8D\a\x12\x2\x2\x8A\x8D\a\b\x2\x2" +
				"\x8B\x8D\x3\x2\x2\x2\x8C\x89\x3\x2\x2\x2\x8C\x8A\x3\x2\x2\x2\x8C\x8B\x3" +
				"\x2\x2\x2\x8D\x17\x3\x2\x2\x2\x8E\x8F\t\x3\x2\x2\x8F\x19\x3\x2\x2\x2\x90" +
				"\x91\a\x19\x2\x2\x91\x1B\x3\x2\x2\x2\x92\x97\x5\x1E\x10\x2\x93\x94\a\x16" +
				"\x2\x2\x94\x96\x5\x1E\x10\x2\x95\x93\x3\x2\x2\x2\x96\x99\x3\x2\x2\x2\x97" +
				"\x95\x3\x2\x2\x2\x97\x98\x3\x2\x2\x2\x98\x9A\x3\x2\x2\x2\x99\x97\x3\x2" +
				"\x2\x2\x9A\x9B\a\t\x2\x2\x9B\x9C\x5,\x17\x2\x9C\xA2\a\xE\x2\x2\x9D\x9E" +
				"\x5,\x17\x2\x9E\x9F\a\xE\x2\x2\x9F\xA1\x3\x2\x2\x2\xA0\x9D\x3\x2\x2\x2" +
				"\xA1\xA4\x3\x2\x2\x2\xA2\xA0\x3\x2\x2\x2\xA2\xA3\x3\x2\x2\x2\xA3\xA5\x3" +
				"\x2\x2\x2\xA4\xA2\x3\x2\x2\x2\xA5\xA6\a\n\x2\x2\xA6\x1D\x3\x2\x2\x2\xA7" +
				"\xAD\x5 \x11\x2\xA8\xA9\x5\x16\f\x2\xA9\xAA\x5 \x11\x2\xAA\xAC\x3\x2\x2" +
				"\x2\xAB\xA8\x3\x2\x2\x2\xAC\xAF\x3\x2\x2\x2\xAD\xAB\x3\x2\x2\x2\xAD\xAE" +
				"\x3\x2\x2\x2\xAE\x1F\x3\x2\x2\x2\xAF\xAD\x3\x2\x2\x2\xB0\xB4\x5&\x14\x2" +
				"\xB1\xB3\x5\"\x12\x2\xB2\xB1\x3\x2\x2\x2\xB3\xB6\x3\x2\x2\x2\xB4\xB2\x3" +
				"\x2\x2\x2\xB4\xB5\x3\x2\x2\x2\xB5\xBD\x3\x2\x2\x2\xB6\xB4\x3\x2\x2\x2" +
				"\xB7\xB9\x5\"\x12\x2\xB8\xB7\x3\x2\x2\x2\xB9\xBA\x3\x2\x2\x2\xBA\xB8\x3" +
				"\x2\x2\x2\xBA\xBB\x3\x2\x2\x2\xBB\xBD\x3\x2\x2\x2\xBC\xB0\x3\x2\x2\x2" +
				"\xBC\xB8\x3\x2\x2\x2\xBD!\x3\x2\x2\x2\xBE\xC3\a\x1A\x2\x2\xBF\xC3\x5$" +
				"\x13\x2\xC0\xC3\x5(\x15\x2\xC1\xC3\x5*\x16\x2\xC2\xBE\x3\x2\x2\x2\xC2" +
				"\xBF\x3\x2\x2\x2\xC2\xC0\x3\x2\x2\x2\xC2\xC1\x3\x2\x2\x2\xC3#\x3\x2\x2" +
				"\x2\xC4\xC5\a\x17\x2\x2\xC5\xC6\a\x19\x2\x2\xC6%\x3\x2\x2\x2\xC7\xC8\t" +
				"\x4\x2\x2\xC8\'\x3\x2\x2\x2\xC9\xCA\a\v\x2\x2\xCA\xCD\a\x19\x2\x2\xCB" +
				"\xCC\t\x5\x2\x2\xCC\xCE\t\x6\x2\x2\xCD\xCB\x3\x2\x2\x2\xCD\xCE\x3\x2\x2" +
				"\x2\xCE\xCF\x3\x2\x2\x2\xCF\xD0\a\f\x2\x2\xD0)\x3\x2\x2\x2\xD1\xD2\a\xF" +
				"\x2\x2\xD2\xD8\a\x19\x2\x2\xD3\xD5\a\x14\x2\x2\xD4\xD6\a\x19\x2\x2\xD5" +
				"\xD4\x3\x2\x2\x2\xD5\xD6\x3\x2\x2\x2\xD6\xD7\x3\x2\x2\x2\xD7\xD9\a\x15" +
				"\x2\x2\xD8\xD3\x3\x2\x2\x2\xD8\xD9\x3\x2\x2\x2\xD9+\x3\x2\x2\x2\xDA\xDB" +
				"\x5\x1A\xE\x2\xDB\xDC\a\xF\x2\x2\xDC\xDE\x5\x30\x19\x2\xDD\xDF\x5.\x18" +
				"\x2\xDE\xDD\x3\x2\x2\x2\xDE\xDF\x3\x2\x2\x2\xDF-\x3\x2\x2\x2\xE0\xE1\a" +
				"\x1F\x2\x2\xE1/\x3\x2\x2\x2\xE2\xE8\x5\x32\x1A\x2\xE3\xE4\x5\x14\v\x2" +
				"\xE4\xE5\x5\x32\x1A\x2\xE5\xE7\x3\x2\x2\x2\xE6\xE3\x3\x2\x2\x2\xE7\xEA" +
				"\x3\x2\x2\x2\xE8\xE6\x3\x2\x2\x2\xE8\xE9\x3\x2\x2\x2\xE9\x31\x3\x2\x2" +
				"\x2\xEA\xE8\x3\x2\x2\x2\xEB\xED\x5\x18\r\x2\xEC\xEB\x3\x2\x2\x2\xEC\xED" +
				"\x3\x2\x2\x2\xED\xEE\x3\x2\x2\x2\xEE\xFA\t\a\x2\x2\xEF\xFA\a\x18\x2\x2" +
				"\xF0\xF5\a\x19\x2\x2\xF1\xF2\a\x14\x2\x2\xF2\xF3\x5\x30\x19\x2\xF3\xF4" +
				"\a\x15\x2\x2\xF4\xF6\x3\x2\x2\x2\xF5\xF1\x3\x2\x2\x2\xF5\xF6\x3\x2\x2" +
				"\x2\xF6\xFA\x3\x2\x2\x2\xF7\xFA\a)\x2\x2\xF8\xFA\x5\x34\x1B\x2\xF9\xEC" +
				"\x3\x2\x2\x2\xF9\xEF\x3\x2\x2\x2\xF9\xF0\x3\x2\x2\x2\xF9\xF7\x3\x2\x2" +
				"\x2\xF9\xF8\x3\x2\x2\x2\xFA\x33\x3\x2\x2\x2\xFB\xFC\a\x1A\x2\x2\xFC\x35" +
				"\x3\x2\x2\x2\xFD\xFE\a\x3\x2\x2\xFE\x37\x3\x2\x2\x2\x1C<\x46OR\\hnr|\x87" +
				"\x8C\x97\xA2\xAD\xB4\xBA\xBC\xC2\xCD\xD5\xD8\xDE\xE8\xEC\xF5\xF9";
		public static readonly ATN _ATN =
			ATNSimulator.Deserialize(_serializedATN.ToCharArray());
	}
} // namespace CSSParserAntlr
